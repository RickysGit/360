<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>360 圖片本機圖庫</title>
  <style>
    :root{
      --bg:#0b0e14;
      --panel:#121726;
      --panel2:#0f1422;
      --text:#e8eefc;
      --muted:#94a3b8;
      --accent:#6ee7ff;
      --danger:#ff6b6b;
      --shadow: 0 12px 40px rgba(0,0,0,.45);
      --radius: 14px;
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; margin:0; background:var(--bg); color:var(--text); font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC", Arial; }
    a{ color:inherit; }

    .app{
      min-height:100%;
      display:flex;
      flex-direction:column;
    }

    header{
      position:sticky; top:0; z-index:10;
      background: linear-gradient(180deg, rgba(11,14,20,.95), rgba(11,14,20,.78));
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(255,255,255,.06);
    }
    .topbar{
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      padding:14px 14px 10px;
      max-width:1100px; margin:0 auto;
    }
    .brand{
      display:flex; gap:10px; align-items:center;
      min-width:0;
    }
    .dot{
      width:10px; height:10px; border-radius:999px;
      background: var(--accent);
      box-shadow: 0 0 18px rgba(110,231,255,.6);
      flex:0 0 auto;
    }
    .titlewrap{ min-width:0; }
    .title{
      font-size:15px; font-weight:700; letter-spacing:.2px;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .subtitle{
      font-size:12px; color:var(--muted);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }

    .actions{
      display:flex; gap:8px; align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    button, .btn{
      appearance:none; border:1px solid rgba(255,255,255,.10);
      background: rgba(18,23,38,.85);
      color:var(--text);
      padding:10px 10px;
      border-radius:12px;
      font-size:13px;
      cursor:pointer;
      user-select:none;
      transition: transform .06s ease, border-color .18s ease, background .18s ease;
    }
    button:hover{ border-color: rgba(110,231,255,.35); }
    button:active{ transform: translateY(1px) scale(.99); }
    button.secondary{
      background: rgba(15,20,34,.85);
    }
    button.danger{
      border-color: rgba(255,107,107,.35);
      background: rgba(28,14,18,.75);
      color: #ffd1d1;
    }
    button:disabled{
      opacity:.55; cursor:not-allowed;
    }

    main{
      flex:1;
      width:100%;
      max-width:1100px;
      margin:0 auto;
      padding:14px;
    }

    .info{
      padding:12px 14px;
      background: linear-gradient(180deg, rgba(18,23,38,.9), rgba(18,23,38,.55));
      border: 1px solid rgba(255,255,255,.08);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      margin-bottom: 14px;
    }
    .info-row{
      display:flex; gap:10px; align-items:flex-start; justify-content:space-between;
      flex-wrap:wrap;
    }
    .path{
      font-size:13px; color: var(--muted);
      line-height:1.4;
    }
    .path b{ color: var(--text); }
    .hint{
      font-size:12px; color: var(--muted);
      line-height:1.5;
      margin-top:8px;
    }

    .section{
      margin: 18px 0 26px;
    }
    .section h2{
      margin: 0 0 10px;
      font-size: 14px;
      color: var(--text);
      letter-spacing:.2px;
      display:flex; align-items:center; gap:10px;
    }
    .pill{
      font-size:12px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      color: var(--muted);
      background: rgba(18,23,38,.55);
    }

    .grid{
      display:grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 10px;
    }

    .card{
      position:relative;
      border-radius: 14px;
      overflow:hidden;
      background: rgba(18,23,38,.55);
      border: 1px solid rgba(255,255,255,.08);
      cursor:pointer;
      box-shadow: 0 8px 22px rgba(0,0,0,.28);
      transition: transform .10s ease, border-color .18s ease;
    }
    .card:hover{
      transform: translateY(-1px);
      border-color: rgba(110,231,255,.25);
    }
    .thumb{
      width:100%; height: 110px;
      display:block;
      object-fit:cover;
      background: #070a10;
    }
    .meta{
      padding: 10px 10px 11px;
      display:flex; flex-direction:column; gap:4px;
    }
    .name{
      font-size:12px;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
      color: var(--text);
    }
    .time{
      font-size:11px;
      color: var(--muted);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }

    /* Viewer modal */
    .viewer{
      position:fixed;
      inset:0;
      z-index:999;
      display:none;
      background: rgba(0,0,0,.88);
      touch-action:none;
    }
    .viewer.show{ display:block; }

    #glcanvas{
      width:100%;
      height:100%;
      display:block;
      outline:none;
      background: #000;
    }

    .v-ui{
      position:absolute; inset:0;
      pointer-events:none; /* buttons will re-enable */
    }
    .v-top{
      position:absolute; left: 10px; right: 10px; top: 10px;
      display:flex; align-items:center; justify-content:space-between;
      gap: 10px;
      pointer-events:none;
    }
    .v-top .left, .v-top .right{
      display:flex; gap: 8px; align-items:center;
      pointer-events:auto;
    }

    .v-bottom{
      position:absolute; left: 10px; right: 10px; bottom: 14px;
      display:flex; align-items:center; justify-content:center;
      gap: 12px;
      pointer-events:none;
    }
    .v-bottom .nav{
      display:flex; align-items:center; gap: 10px;
      pointer-events:auto;
      background: rgba(18,23,38,.55);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 999px;
      padding: 8px 10px;
      backdrop-filter: blur(8px);
    }
    .v-bottom .label{
      font-size:12px; color: var(--text);
      max-width: 46vw;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .v-badge{
      position:absolute; left: 12px; bottom: 70px;
      background: rgba(18,23,38,.55);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 10px;
      padding: 8px 10px;
      color: var(--muted);
      font-size: 12px;
      pointer-events:none;
      backdrop-filter: blur(8px);
      max-width: 90vw;
      line-height:1.35;
    }
    .hidden-ui .v-ui{ display:none; }

    input[type="file"]{ display:none; }
    .toast{
      position:fixed;
      left:50%; bottom:20px;
      transform: translateX(-50%);
      background: rgba(18,23,38,.85);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 999px;
      padding: 10px 12px;
      color: var(--text);
      font-size:12px;
      box-shadow: var(--shadow);
      opacity:0;
      pointer-events:none;
      transition: opacity .2s ease, transform .2s ease;
    }
    .toast.show{
      opacity:1;
      transform: translateX(-50%) translateY(-4px);
    }

    @media (max-width: 520px){
      .grid{ grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); }
      .thumb{ height: 104px; }
      button{ padding:10px 10px; }
    }
  </style>
</head>
<body>
<div class="app">
  <header>
    <div class="topbar">
      <div class="brand">
        <div class="dot"></div>
        <div class="titlewrap">
          <div class="title">360 圖片本機圖庫</div>
          <div class="subtitle" id="subline">離線可用｜縮圖分月｜360 拖曳/縮放（含小星球）</div>
        </div>
      </div>

      <div class="actions">
        <label class="btn" for="fileInput" id="addBtn">新增圖片</label>
        <button class="secondary" id="pickFolderBtn" title="Chrome/Edge 可選資料夾保存，其他瀏覽器會忽略">選擇資料夾（可顯示路徑）</button>
        <button class="secondary" id="exportBtn" title="匯出 JSON + 圖片 Blob（適合備份）">匯出備份</button>
        <button class="danger" id="clearBtn" title="清空此圖庫（不可復原）">清空圖庫</button>
      </div>
    </div>
  </header>

  <main>
    <div class="info">
      <div class="info-row">
        <div class="path" id="storageLine">
          儲存模式：<b>瀏覽器離線資料庫（IndexedDB）</b><br/>
          本地儲存路徑：<b id="pathText">（瀏覽器安全限制，預設不提供實體路徑）</b>
        </div>
        <div class="path" id="countLine">共 <b id="countText">0</b> 張</div>
      </div>
      <div class="hint">
        分類優先讀取 JPEG EXIF「拍攝時間」，讀不到就用「上傳時間」。<br/>
        操作：拖曳/滑動＝環視，滾輪或雙指捏合＝縮放；縮放到更遠會進入「小星球」效果；輕點畫面可隱藏/顯示 UI。
      </div>
    </div>

    <div id="library"></div>
  </main>
</div>

<!-- viewer -->
<div class="viewer" id="viewer">
  <canvas id="glcanvas"></canvas>
  <div class="v-ui">
    <div class="v-top">
      <div class="left">
        <button id="backBtn" title="返回">返回</button>
      </div>
      <div class="right">
        <button id="shotBtn" class="secondary" title="截圖下載 PNG">截圖</button>
      </div>
    </div>
    <div class="v-bottom">
      <div class="nav">
        <button id="prevBtn" class="secondary" title="上一張">◀</button>
        <div class="label" id="vLabel">—</div>
        <button id="nextBtn" class="secondary" title="下一張">▶</button>
      </div>
    </div>
    <div class="v-badge" id="vBadge">—</div>
  </div>
</div>

<input id="fileInput" type="file" accept="image/*" multiple />

<div class="toast" id="toast"></div>

<script>
/* ===========================
   1) 小工具：Toast
=========================== */
const Toast = (() => {
  let t = null, timer = null;
  function show(msg, ms=1600){
    if(!t) t = document.getElementById('toast');
    t.textContent = msg;
    t.classList.add('show');
    clearTimeout(timer);
    timer = setTimeout(()=> t.classList.remove('show'), ms);
  }
  return { show };
})();

/* ===========================
   2) IndexedDB（Blob 存圖 + 縮圖）
=========================== */
const DB = (() => {
  const DB_NAME = 'local_360_library_v1';
  const DB_VER  = 1;
  const STORE   = 'photos';
  let _db = null;

  function open(){
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, DB_VER);
      req.onupgradeneeded = (e) => {
        const db = req.result;
        if(!db.objectStoreNames.contains(STORE)){
          const os = db.createObjectStore(STORE, { keyPath: 'id' });
          os.createIndex('by_time', 'sortTime', { unique:false });
          os.createIndex('by_month', 'ym', { unique:false });
        }
        if(!db.objectStoreNames.contains('settings')){
          db.createObjectStore('settings', { keyPath: 'key' });
        }
      };
      req.onsuccess = () => { _db = req.result; resolve(); };
      req.onerror = () => reject(req.error);
    });
  }

  function tx(store, mode='readonly'){
    const t = _db.transaction(store, mode);
    return t.objectStore(store);
  }

  function putPhoto(rec){
    return new Promise((resolve, reject)=>{
      const os = tx(STORE, 'readwrite');
      const r = os.put(rec);
      r.onsuccess = ()=> resolve();
      r.onerror = ()=> reject(r.error);
    });
  }

  function getAllPhotos(){
    return new Promise((resolve, reject)=>{
      const os = tx(STORE, 'readonly');
      const r = os.getAll();
      r.onsuccess = ()=> resolve(r.result || []);
      r.onerror = ()=> reject(r.error);
    });
  }

  function deleteAllPhotos(){
    return new Promise((resolve, reject)=>{
      const os = tx(STORE, 'readwrite');
      const r = os.clear();
      r.onsuccess = ()=> resolve();
      r.onerror = ()=> reject(r.error);
    });
  }

  function putSetting(key, value){
    return new Promise((resolve, reject)=>{
      const os = tx('settings', 'readwrite');
      const r = os.put({ key, value });
      r.onsuccess = ()=> resolve();
      r.onerror = ()=> reject(r.error);
    });
  }

  function getSetting(key){
    return new Promise((resolve, reject)=>{
      const os = tx('settings', 'readonly');
      const r = os.get(key);
      r.onsuccess = ()=> resolve(r.result ? r.result.value : null);
      r.onerror = ()=> reject(r.error);
    });
  }

  return { open, putPhoto, getAllPhotos, deleteAllPhotos, putSetting, getSetting };
})();

/* ===========================
   3) EXIF（JPEG 常見格式）讀取 DateTimeOriginal
   - 讀不到就回 null
=========================== */
function _getStr(view, off, len){
  let s = '';
  for(let i=0;i<len;i++){
    const c = view.getUint8(off+i);
    if(c===0) break;
    s += String.fromCharCode(c);
  }
  return s;
}
function _readASCII(view, off, count){
  return _getStr(view, off, count);
}
function _parseExifDateFromJpeg(arrayBuffer){
  const view = new DataView(arrayBuffer);
  if(view.byteLength < 4) return null;
  // JPEG SOI
  if(view.getUint16(0, false) !== 0xFFD8) return null;
  let offset = 2;
  while(offset + 4 < view.byteLength){
    if(view.getUint8(offset) !== 0xFF) { offset++; continue; }
    const marker = view.getUint16(offset, false);
    offset += 2;

    // EOI / SOS
    if(marker === 0xFFD9 || marker === 0xFFDA) break;

    const size = view.getUint16(offset, false);
    offset += 2;
    if(size < 2) break;

    // APP1 Exif
    if(marker === 0xFFE1){
      const exifHeader = _getStr(view, offset, 6);
      if(exifHeader === 'Exif\u0000\u0000'){
        const tiffStart = offset + 6;

        const endian = _getStr(view, tiffStart, 2);
        const little = (endian === 'II');
        if(!(endian === 'II' || endian === 'MM')) return null;

        const getU16 = (o)=> view.getUint16(o, little);
        const getU32 = (o)=> view.getUint32(o, little);

        const magic = getU16(tiffStart + 2);
        if(magic !== 0x002A) return null;

        const ifd0Off = getU32(tiffStart + 4);
        const ifd0 = tiffStart + ifd0Off;
        if(ifd0 < 0 || ifd0+2 > view.byteLength) return null;

        function readIFD(ifdAbs){
          const n = getU16(ifdAbs);
          const base = ifdAbs + 2;
          const tags = new Map();
          for(let i=0;i<n;i++){
            const ent = base + i*12;
            if(ent+12 > view.byteLength) break;
            const tag = getU16(ent);
            const type = getU16(ent+2);
            const count = getU32(ent+4);
            const value = getU32(ent+8);
            tags.set(tag, { type, count, value });
          }
          return tags;
        }

        function readTagAscii(tags, tagId){
          const t = tags.get(tagId);
          if(!t) return null;
          if(t.type !== 2) return null; // ASCII
          const count = t.count;
          // value 4 bytes inline if count <= 4, else offset
          let strOff;
          if(count <= 4){
            // value is packed; use its bytes
            const tmp = new Uint8Array(4);
            // write value as endian-specific bytes
            const dv = new DataView(tmp.buffer);
            dv.setUint32(0, t.value, little);
            // build string
            let s = '';
            for(let i=0;i<count;i++){
              const c = tmp[i];
              if(c===0) break;
              s += String.fromCharCode(c);
            }
            return s || null;
          }else{
            strOff = tiffStart + t.value;
            if(strOff < 0 || strOff + count > view.byteLength) return null;
            return _readASCII(view, strOff, count) || null;
          }
        }

        // IFD0: 0x0132 DateTime, 0x8769 ExifIFDPointer
        const tags0 = readIFD(ifd0);
        let dt = readTagAscii(tags0, 0x0132);

        // Exif SubIFD: 0x9003 DateTimeOriginal (優先), 0x9004 DateTimeDigitized
        const exifPtr = tags0.get(0x8769);
        if(exifPtr && exifPtr.type === 4){
          const subIfdAbs = tiffStart + exifPtr.value;
          if(subIfdAbs > 0 && subIfdAbs + 2 < view.byteLength){
            const tagsExif = readIFD(subIfdAbs);
            const dto = readTagAscii(tagsExif, 0x9003) || readTagAscii(tagsExif, 0x9004);
            if(dto) dt = dto;
          }
        }

        if(dt){
          // format: "YYYY:MM:DD HH:MM:SS"
          const m = dt.match(/^(\d{4}):(\d{2}):(\d{2}) (\d{2}):(\d{2}):(\d{2})/);
          if(m){
            const y = +m[1], mo = +m[2]-1, d = +m[3], h = +m[4], mi = +m[5], s = +m[6];
            const date = new Date(y, mo, d, h, mi, s);
            if(!isNaN(date.getTime())) return date;
          }
        }
      }
    }

    offset += (size - 2);
  }
  return null;
}

/* ===========================
   4) 檔案縮圖產生
=========================== */
async function makeThumbnailBlob(file, maxSide=420, quality=0.84){
  const bmp = await createImageBitmap(file);
  const w = bmp.width, h = bmp.height;
  let tw = w, th = h;
  if(Math.max(w,h) > maxSide){
    const s = maxSide / Math.max(w,h);
    tw = Math.round(w*s);
    th = Math.round(h*s);
  }
  const canvas = document.createElement('canvas');
  canvas.width = tw; canvas.height = th;
  const ctx = canvas.getContext('2d', { alpha:false });
  ctx.drawImage(bmp, 0, 0, tw, th);
  bmp.close?.();

  const blob = await new Promise(res => canvas.toBlob(res, 'image/jpeg', quality));
  return blob;
}

/* ===========================
   5) 圖庫 UI：分月渲染
=========================== */
function fmtYM(date){
  const y = date.getFullYear();
  const m = date.getMonth()+1;
  return `${y}年${m}月`;
}
function ymKey(date){
  const y = date.getFullYear();
  const m = date.getMonth()+1;
  return `${y}-${String(m).padStart(2,'0')}`;
}
function fmtTime(date){
  const y = date.getFullYear();
  const m = String(date.getMonth()+1).padStart(2,'0');
  const d = String(date.getDate()).padStart(2,'0');
  const hh = String(date.getHours()).padStart(2,'0');
  const mm = String(date.getMinutes()).padStart(2,'0');
  return `${y}/${m}/${d} ${hh}:${mm}`;
}

let PHOTOS = []; // sorted by sortTime desc
let CURRENT_INDEX = -1;

// storage mode / folder handle
let folderHandle = null;
let folderName = null;

function updateStorageLine(){
  const storageLine = document.getElementById('storageLine');
  const pathText = document.getElementById('pathText');

  if(folderHandle){
    storageLine.innerHTML = `儲存模式：<b>資料夾模式（寫入你選的資料夾）</b><br/>本地儲存路徑：<b id="pathText">${folderName || '（已選資料夾）'}</b>`;
  }else{
    storageLine.innerHTML = `儲存模式：<b>瀏覽器離線資料庫（IndexedDB）</b><br/>本地儲存路徑：<b id="pathText">（瀏覽器安全限制，預設不提供實體路徑）</b>`;
  }
}

function renderLibrary(){
  const lib = document.getElementById('library');
  const countText = document.getElementById('countText');
  countText.textContent = String(PHOTOS.length);

  if(PHOTOS.length === 0){
    lib.innerHTML = `<div class="section">
      <h2>目前沒有圖片 <span class="pill">請按「新增圖片」</span></h2>
      <div class="hint">上傳後會自動產生縮圖並依月份分類。</div>
    </div>`;
    return;
  }

  // group by month
  const groups = new Map();
  for(const p of PHOTOS){
    if(!groups.has(p.ym)) groups.set(p.ym, []);
    groups.get(p.ym).push(p);
  }

  // sort month desc
  const monthKeys = Array.from(groups.keys()).sort((a,b)=> b.localeCompare(a));

  let html = '';
  for(const mk of monthKeys){
    const arr = groups.get(mk);
    const dateForTitle = new Date(+mk.slice(0,4), +mk.slice(5,7)-1, 1);
    const title = fmtYM(dateForTitle);
    html += `<div class="section">
      <h2>${title} <span class="pill">${arr.length} 張</span></h2>
      <div class="grid">
        ${arr.map(p=>{
          return `<div class="card" data-id="${p.id}">
            <img class="thumb" alt="" src="${p.thumbUrl}">
            <div class="meta">
              <div class="name">${escapeHtml(p.name)}</div>
              <div class="time">${p.timeLabel}</div>
            </div>
          </div>`;
        }).join('')}
      </div>
    </div>`;
  }
  lib.innerHTML = html;

  // bind clicks
  lib.querySelectorAll('.card').forEach(el=>{
    el.addEventListener('click', ()=>{
      const id = el.getAttribute('data-id');
      const idx = PHOTOS.findIndex(x=>x.id===id);
      if(idx>=0) openViewerAt(idx);
    });
  });
}

function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, (c)=>({
    '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'
  }[c]));
}

/* ===========================
   6) Viewer：WebGL 360（含小星球）
   - 全螢幕 fragment ray-sphere sampling
=========================== */
const Viewer360 = (() => {
  const viewer = document.getElementById('viewer');
  const canvas = document.getElementById('glcanvas');
  const backBtn = document.getElementById('backBtn');
  const prevBtn = document.getElementById('prevBtn');
  const nextBtn = document.getElementById('nextBtn');
  const shotBtn = document.getElementById('shotBtn');
  const vLabel  = document.getElementById('vLabel');
  const vBadge  = document.getElementById('vBadge');

  let gl = null, prog = null;
  let tex = null;
  let loc = {};
  let raf = 0;

  // camera state
  let yaw = 0;       // radians
  let pitch = 0;     // radians
  let fovDeg = 80;   // 20..140
  let camDist = 0;   // 0..3 (0=inside, >1 outside => little planet)
  let aspect = 1;

  // pointer
  const pointers = new Map();
  let lastTapTime = 0;
  let tapCandidate = null; // {x,y,t}
  let uiHidden = false;

  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  function initGL(){
    gl = canvas.getContext('webgl', { antialias:true, preserveDrawingBuffer:true });
    if(!gl){
      Toast.show('此瀏覽器不支援 WebGL，無法顯示 360。');
      return false;
    }

    const vsSrc = `
      attribute vec2 aPos;
      varying vec2 vUv;
      void main(){
        vUv = aPos * 0.5 + 0.5;
        gl_Position = vec4(aPos, 0.0, 1.0);
      }
    `;
    const fsSrc = `
      precision highp float;
      varying vec2 vUv;
      uniform sampler2D uTex;
      uniform float uAspect;
      uniform float uFov;      // radians
      uniform float uYaw;
      uniform float uPitch;
      uniform float uCamDist;

      // rotate around Y then X
      vec3 rotY(vec3 v, float a){
        float c = cos(a), s = sin(a);
        return vec3(c*v.x + s*v.z, v.y, -s*v.x + c*v.z);
      }
      vec3 rotX(vec3 v, float a){
        float c = cos(a), s = sin(a);
        return vec3(v.x, c*v.y - s*v.z, s*v.y + c*v.z);
      }

      void main(){
        // NDC (-1..1)
        vec2 p = vUv*2.0 - 1.0;
        p.x *= uAspect;

        // camera ray in camera space
        float tanHalf = tan(uFov * 0.5);
        vec3 rd = normalize(vec3(p.x * tanHalf, -p.y * tanHalf, -1.0)); // -Z forward
        rd = rotY(rd, uYaw);
        rd = rotX(rd, uPitch);

        vec3 ro = vec3(0.0, 0.0, uCamDist);

        // Ray-sphere intersection (sphere radius 1 at origin)
        float b = dot(ro, rd);
        float c = dot(ro, ro) - 1.0;
        float h = b*b - c;
        if(h < 0.0){
          gl_FragColor = vec4(0.0,0.0,0.0,1.0);
          return;
        }
        float t = -b - sqrt(h);
        if(t < 0.0){
          t = -b + sqrt(h);
        }
        if(t < 0.0){
          gl_FragColor = vec4(0.0,0.0,0.0,1.0);
          return;
        }
        vec3 hit = normalize(ro + rd * t);

        // Convert to equirectangular UV
        // theta: atan2(z, x), phi: asin(y)
        float theta = atan(hit.z, hit.x);
        float phi = asin(clamp(hit.y, -1.0, 1.0));
        float u = 0.5 + theta / (2.0 * 3.141592653589793);
        float v = 0.5 - phi / 3.141592653589793;

        vec3 col = texture2D(uTex, vec2(u, v)).rgb;
        gl_FragColor = vec4(col, 1.0);
      }
    `;

    function compile(type, src){
      const sh = gl.createShader(type);
      gl.shaderSource(sh, src);
      gl.compileShader(sh);
      if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)){
        console.error(gl.getShaderInfoLog(sh));
        Toast.show('Shader 編譯失敗（請用 Chrome/Edge）。');
        return null;
      }
      return sh;
    }

    const vs = compile(gl.VERTEX_SHADER, vsSrc);
    const fs = compile(gl.FRAGMENT_SHADER, fsSrc);
    if(!vs || !fs) return false;

    prog = gl.createProgram();
    gl.attachShader(prog, vs);
    gl.attachShader(prog, fs);
    gl.linkProgram(prog);
    if(!gl.getProgramParameter(prog, gl.LINK_STATUS)){
      console.error(gl.getProgramInfoLog(prog));
      Toast.show('Shader 連結失敗。');
      return false;
    }

    gl.useProgram(prog);

    // fullscreen triangle strip quad
    const buf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buf);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
      -1,-1,  1,-1,  -1, 1,
      -1, 1,  1,-1,   1, 1
    ]), gl.STATIC_DRAW);

    const aPos = gl.getAttribLocation(prog, 'aPos');
    gl.enableVertexAttribArray(aPos);
    gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

    loc.uTex = gl.getUniformLocation(prog, 'uTex');
    loc.uAspect = gl.getUniformLocation(prog, 'uAspect');
    loc.uFov = gl.getUniformLocation(prog, 'uFov');
    loc.uYaw = gl.getUniformLocation(prog, 'uYaw');
    loc.uPitch = gl.getUniformLocation(prog, 'uPitch');
    loc.uCamDist = gl.getUniformLocation(prog, 'uCamDist');

    tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    gl.uniform1i(loc.uTex, 0);

    resize();
    window.addEventListener('resize', resize);

    // UI events
    backBtn.addEventListener('click', close);
    prevBtn.addEventListener('click', ()=> window.__viewerNav?.(-1));
    nextBtn.addEventListener('click', ()=> window.__viewerNav?.( 1));
    shotBtn.addEventListener('click', screenshot);

    // pointer events
    viewer.addEventListener('pointerdown', onPointerDown, { passive:false });
    viewer.addEventListener('pointermove', onPointerMove, { passive:false });
    viewer.addEventListener('pointerup', onPointerUp, { passive:false });
    viewer.addEventListener('pointercancel', onPointerUp, { passive:false });
    viewer.addEventListener('wheel', onWheel, { passive:false });

    return true;
  }

  function resize(){
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    const w = Math.floor(viewer.clientWidth * dpr);
    const h = Math.floor(viewer.clientHeight * dpr);
    canvas.width = w; canvas.height = h;
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    if(gl){
      gl.viewport(0,0,w,h);
      aspect = w / h;
    }
  }

  function setBadge(text){
    vBadge.textContent = text;
  }

  function toggleUI(force){
    uiHidden = (typeof force === 'boolean') ? force : !uiHidden;
    viewer.classList.toggle('hidden-ui', uiHidden);
  }

  function onPointerDown(e){
    e.preventDefault();
    viewer.setPointerCapture?.(e.pointerId);
    pointers.set(e.pointerId, { x:e.clientX, y:e.clientY });
    if(pointers.size === 1){
      tapCandidate = { x:e.clientX, y:e.clientY, t: performance.now() };
    }else{
      tapCandidate = null;
    }
  }

  function onPointerMove(e){
    if(!pointers.has(e.pointerId)) return;
    e.preventDefault();

    const p = pointers.get(e.pointerId);
    const nx = e.clientX, ny = e.clientY;
    const dx = nx - p.x;
    const dy = ny - p.y;
    pointers.set(e.pointerId, { x:nx, y:ny });

    if(pointers.size === 1){
      // drag rotate
      const sens = 0.0045;
      yaw   += dx * sens;
      pitch += dy * sens;
      pitch = clamp(pitch, -1.45, 1.45); // about +-83 deg
      if(tapCandidate){
        const dist = Math.hypot(nx - tapCandidate.x, ny - tapCandidate.y);
        if(dist > 6) tapCandidate = null; // no longer a tap
      }
    }else if(pointers.size === 2){
      // pinch zoom
      const pts = Array.from(pointers.values());
      // current distance
      const d = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
      // store in map for each move: we need previous distance
      if(!onPointerMove._lastPinchDist){
        onPointerMove._lastPinchDist = d;
        return;
      }
      const delta = d - onPointerMove._lastPinchDist;
      onPointerMove._lastPinchDist = d;
      zoomBy(delta * 0.07); // tune
      tapCandidate = null;
    }
  }
  onPointerMove._lastPinchDist = 0;

  function onPointerUp(e){
    e.preventDefault();
    pointers.delete(e.pointerId);
    if(pointers.size < 2){
      onPointerMove._lastPinchDist = 0;
    }

    // tap to toggle UI
    if(tapCandidate){
      const dt = performance.now() - tapCandidate.t;
      if(dt < 260){
        toggleUI();
      }
      tapCandidate = null;
    }
  }

  function onWheel(e){
    e.preventDefault();
    // wheel up => zoom in
    zoomBy(-e.deltaY * 0.02);
  }

  function zoomBy(amount){
    // amount >0 means zoom out
    // 1) adjust fov first (20..140)
    const prevFov = fovDeg;
    fovDeg = clamp(fovDeg + amount, 20, 140);

    // 2) when fov already max and still zooming out, move camera out (0..3)
    if(prevFov >= 139.5 && amount > 0){
      camDist = clamp(camDist + amount * 0.02, 0, 3.0);
    }
    // 3) when zooming in, pull camera back toward inside
    if(amount < 0){
      camDist = clamp(camDist + amount * 0.03, 0, 3.0);
    }

    const mode = (camDist > 0.15) ? '小星球' : '360';
    setBadge(`模式：${mode}｜FOV：${Math.round(fovDeg)}°｜縮放：${camDist > 0.15 ? ('外觀距離 '+camDist.toFixed(2)) : '內部'}`);
  }

  async function loadTextureFromBlob(blob){
    if(!gl) return;
    const url = URL.createObjectURL(blob);
    const img = new Image();
    img.decoding = 'async';
    img.src = url;
    await img.decode().catch(()=>{});
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, img);
    URL.revokeObjectURL(url);
  }

  function draw(){
    if(!gl) return;
    gl.useProgram(prog);
    gl.uniform1f(loc.uAspect, aspect);
    gl.uniform1f(loc.uFov, fovDeg * Math.PI / 180);
    gl.uniform1f(loc.uYaw, yaw);
    gl.uniform1f(loc.uPitch, pitch);
    gl.uniform1f(loc.uCamDist, camDist);

    gl.drawArrays(gl.TRIANGLES, 0, 6);
    raf = requestAnimationFrame(draw);
  }

  function open(){
    viewer.classList.add('show');
    toggleUI(false);
    if(!gl){
      const ok = initGL();
      if(!ok) return;
    }
    resize();
    cancelAnimationFrame(raf);
    raf = requestAnimationFrame(draw);
  }

  function close(){
    viewer.classList.remove('show');
    cancelAnimationFrame(raf);
  }

  function screenshot(){
    try{
      canvas.toBlob((blob)=>{
        if(!blob){
          Toast.show('截圖失敗（toBlob 不可用）');
          return;
        }
        const a = document.createElement('a');
        const url = URL.createObjectURL(blob);
        a.href = url;
        a.download = `360_screenshot_${Date.now()}.png`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(()=> URL.revokeObjectURL(url), 800);
        Toast.show('已下載截圖');
      }, 'image/png');
    }catch(err){
      console.error(err);
      Toast.show('截圖失敗（瀏覽器限制）');
    }
  }

  function setLabel(text){ vLabel.textContent = text; }

  return { open, close, loadTextureFromBlob, setLabel, setBadge, zoomBy, resetView: ()=>{
    yaw = 0; pitch = 0; fovDeg = 80; camDist = 0;
    setBadge(`模式：360｜FOV：${Math.round(fovDeg)}°｜縮放：內部`);
  }};
})();

/* ===========================
   7) 上傳流程：讀 EXIF / 建縮圖 / 存 DB
=========================== */
function uuid(){
  return 'p_' + Math.random().toString(16).slice(2) + '_' + Date.now().toString(16);
}

async function addFiles(files){
  const list = Array.from(files || []);
  if(list.length === 0) return;

  Toast.show(`處理中：${list.length} 張…`, 1400);

  for(const file of list){
    try{
      const addedAt = new Date();
      let takenAt = null;

      // EXIF only for jpeg
      if(/jpe?g/i.test(file.type) || /\.jpe?g$/i.test(file.name)){
        const buf = await file.arrayBuffer();
        takenAt = _parseExifDateFromJpeg(buf);
      }
      if(!takenAt) takenAt = addedAt;

      const sortTime = takenAt.getTime();
      const ym = ymKey(takenAt);

      // thumbnail
      const thumbBlob = await makeThumbnailBlob(file);
      const imageBlob = file.slice(0, file.size, file.type || 'image/jpeg');

      // (optional) folder mode: write into picked folder
      // - 這邊只能拿到檔名，無法保證是「絕對路徑」
      if(folderHandle){
        try{
          const safeName = file.name || (`photo_${Date.now()}.jpg`);
          const fileHandle = await folderHandle.getFileHandle(safeName, { create:true });
          const writable = await fileHandle.createWritable();
          await writable.write(imageBlob);
          await writable.close();
        }catch(err){
          console.warn('folder write failed', err);
          Toast.show('寫入資料夾失敗：改用瀏覽器離線儲存', 1800);
          folderHandle = null;
          folderName = null;
          await DB.putSetting('folderHandle', null);
          updateStorageLine();
        }
      }

      // store in IndexedDB for guaranteed offline use
      const id = uuid();
      const rec = {
        id,
        name: file.name || '(未命名)',
        type: file.type || 'image/*',
        size: file.size,
        addedAt: addedAt.toISOString(),
        takenAt: takenAt.toISOString(),
        sortTime,
        ym,
        timeLabel: `拍攝/上傳：${fmtTime(takenAt)}${(takenAt.getTime()!==addedAt.getTime()) ? '' : '（上傳時間）'}`,
        thumbBlob,
        imageBlob
      };
      await DB.putPhoto(rec);
    }catch(err){
      console.error(err);
      Toast.show(`有一張圖片處理失敗：${file.name}`, 2000);
    }
  }

  await reloadFromDB();
  Toast.show('已新增完成');
}

/* ===========================
   8) 載入 DB → 產生 URL → 渲染
=========================== */
function revokePhotoUrls(){
  for(const p of PHOTOS){
    if(p.thumbUrl) URL.revokeObjectURL(p.thumbUrl);
  }
}

async function reloadFromDB(){
  revokePhotoUrls();
  const all = await DB.getAllPhotos();

  // convert blobs to URLs for thumb; keep imageBlob in memory reference (still from IDB object)
  PHOTOS = all.map(r=>{
    return {
      ...r,
      thumbUrl: URL.createObjectURL(r.thumbBlob),
      // imageBlob kept
    };
  }).sort((a,b)=> b.sortTime - a.sortTime);

  renderLibrary();
}

/* ===========================
   9) Viewer 導航（上一張/下一張）
=========================== */
async function openViewerAt(index){
  if(index < 0 || index >= PHOTOS.length) return;
  CURRENT_INDEX = index;
  const p = PHOTOS[CURRENT_INDEX];

  Viewer360.open();
  Viewer360.resetView();
  Viewer360.setLabel(`${p.name}（${CURRENT_INDEX+1}/${PHOTOS.length}）`);
  Viewer360.setBadge('載入中…');

  await Viewer360.loadTextureFromBlob(p.imageBlob);
  Viewer360.setBadge(`模式：360｜FOV：80°｜縮放：內部｜${p.timeLabel}`);
}

window.__viewerNav = async function(step){
  if(PHOTOS.length === 0) return;
  let idx = CURRENT_INDEX + step;
  if(idx < 0) idx = PHOTOS.length - 1;
  if(idx >= PHOTOS.length) idx = 0;
  await openViewerAt(idx);
};

/* ===========================
   10) 匯出/清空/資料夾模式
=========================== */
async function exportBackup(){
  const all = await DB.getAllPhotos();
  if(all.length === 0){
    Toast.show('目前沒有資料可匯出');
    return;
  }
  // export json + images as a simple JSON (base64 is huge) => we export a .json + separate blobs via zip? (不引入外部庫)
  // 這裡做「JSON（不含 blob） + 逐張下載原圖」的簡易版
  const meta = all.map(p=>({
    id:p.id, name:p.name, type:p.type, size:p.size,
    addedAt:p.addedAt, takenAt:p.takenAt, ym:p.ym, sortTime:p.sortTime
  }));
  const blob = new Blob([JSON.stringify({ exportedAt:new Date().toISOString(), meta }, null, 2)], { type:'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `360_library_backup_${Date.now()}.json`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=> URL.revokeObjectURL(url), 800);

  Toast.show('已匯出備份 JSON（不含圖片本體）', 2200);
}

async function clearLibrary(){
  if(!confirm('確定要清空圖庫？此動作不可復原。')) return;
  await DB.deleteAllPhotos();
  await reloadFromDB();
  Toast.show('已清空');
}

async function pickFolder(){
  if(!('showDirectoryPicker' in window)){
    Toast.show('此瀏覽器不支援「選擇資料夾」功能（請用 Chrome/Edge）', 2200);
    return;
  }
  try{
    const handle = await window.showDirectoryPicker({ mode:'readwrite' });
    folderHandle = handle;
    folderName = handle.name || '（已選資料夾）';

    // 儲存 handle（部分瀏覽器允許把 handle 存進 IndexedDB）
    await DB.putSetting('folderHandle', handle);
    await DB.putSetting('folderName', folderName);
    updateStorageLine();
    Toast.show('已選擇資料夾（之後新增圖片會嘗試寫入該資料夾）', 2200);
  }catch(err){
    // user cancel
    console.warn(err);
  }
}

/* ===========================
   11) 初始化
=========================== */
document.getElementById('fileInput').addEventListener('change', async (e)=>{
  const files = e.target.files;
  // reset input so re-upload same files still triggers
  e.target.value = '';
  await addFiles(files);
});

document.getElementById('clearBtn').addEventListener('click', clearLibrary);
document.getElementById('exportBtn').addEventListener('click', exportBackup);
document.getElementById('pickFolderBtn').addEventListener('click', pickFolder);
document.getElementById('backBtn').addEventListener('click', ()=> Viewer360.close());

(async function init(){
  await DB.open();

  // restore folder handle if possible
  try{
    const savedHandle = await DB.getSetting('folderHandle');
    const savedName = await DB.getSetting('folderName');
    if(savedHandle){
      // permission check
      const perm = await savedHandle.queryPermission?.({ mode:'readwrite' });
      if(perm === 'granted'){
        folderHandle = savedHandle;
        folderName = savedName || savedHandle.name || '（已選資料夾）';
      }
    }
  }catch(err){
    // ignore if handle restore not supported
    console.warn('folder handle restore failed', err);
  }

  updateStorageLine();
  await reloadFromDB();
})();
</script>
</body>
</html>
